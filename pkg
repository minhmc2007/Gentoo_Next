#!/usr/bin/env python3
import os
import sys
import argparse
import subprocess
import datetime
import re
import json
import shlex

# --- CONSTANTS ---
CONFIG_FILE = "/etc/pkg/config"
LOG_DIR = "/var/log/pkg"
LOG_FILE = os.path.join(LOG_DIR, "history.log")
CACHE_DIR = "/var/cache/pkg"
CACHE_FILE = os.path.join(CACHE_DIR, "pkg_index.json")
REPO_PATH = "/var/db/repos/gentoo" 

# --- 1. LOGGER (Real-time & Strip ANSI for file) ---
class PkgLogger:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

    def __init__(self):
        self._ensure_dir(LOG_DIR)
        
    def _ensure_dir(self, path):
        if not os.path.exists(path):
            try:
                os.makedirs(path, exist_ok=True)
            except PermissionError:
                # Nếu không phải root, có thể không tạo được folder log
                # Bỏ qua, chỉ in ra màn hình
                pass

    def _strip_ansi(self, text):
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        return ansi_escape.sub('', text)

    def log_to_file(self, msg):
        try:
            with open(LOG_FILE, "a", encoding="utf-8") as f:
                timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                clean_msg = self._strip_ansi(msg)
                f.write(f"[{timestamp}] {clean_msg}\n")
        except PermissionError:
            pass 
        except FileNotFoundError:
            pass

    def info(self, msg):
        formatted = f"{self.BLUE}[PKG]{self.ENDC} {msg}"
        print(formatted)
        self.log_to_file(f"[INFO] {msg}")

    def success(self, msg):
        formatted = f"{self.GREEN}[OK]{self.ENDC} {msg}"
        print(formatted)
        self.log_to_file(f"[SUCCESS] {msg}")

    def warn(self, msg):
        formatted = f"{self.WARNING}[WARN]{self.ENDC} {msg}"
        print(formatted)
        self.log_to_file(f"[WARN] {msg}")

    def error(self, msg):
        formatted = f"{self.FAIL}[ERROR]{self.ENDC} {msg}"
        print(formatted, file=sys.stderr)
        self.log_to_file(f"[ERROR] {msg}")

# --- 2. CACHE MANAGER ---
class PkgCache:
    def __init__(self, logger):
        self.logger = logger
        
    def update_index(self):
        self.logger.info("Updating package cache (Indexing)...")
        
        if not os.path.exists(REPO_PATH):
            self.logger.warn(f"Repo not found at {REPO_PATH}. Skipping index.")
            return

        packages = []
        try:
            categories = [d for d in os.listdir(REPO_PATH) if os.path.isdir(os.path.join(REPO_PATH, d)) and d[0] not in '._']
            count = 0
            for cat in categories:
                cat_path = os.path.join(REPO_PATH, cat)
                pkgs = [p for p in os.listdir(cat_path) if os.path.isdir(os.path.join(cat_path, p))]
                for p in pkgs:
                    packages.append(f"{cat}/{p}")
                    count += 1
            
            if not os.path.exists(CACHE_DIR):
                os.makedirs(CACHE_DIR, exist_ok=True)
                
            with open(CACHE_FILE, 'w') as f:
                json.dump(packages, f)
            self.logger.success(f"Indexed {count} packages into cache.")
            
        except PermissionError:
            self.logger.error("Root privileges required to write cache.")
        except Exception as e:
            self.logger.error(f"Indexing error: {e}")

    def search(self, keyword):
        if not os.path.exists(CACHE_FILE):
            self.logger.warn("Cache does not exist. Please run 'pkg update' first.")
            self.logger.info("Falling back to 'emerge --search' (slow)...")
            return False

        try:
            with open(CACHE_FILE, 'r') as f:
                all_pkgs = json.load(f)
            
            results = [p for p in all_pkgs if keyword in p]
            
            if not results:
                self.logger.warn(f"No packages found matching '{keyword}' in cache.")
            else:
                print(f"\n{PkgLogger.BOLD}Search Results (Cache Hit):{PkgLogger.ENDC}")
                limit = 20
                for i, p in enumerate(results):
                    if i >= limit:
                        print(f"  ... and {len(results) - limit} more results.")
                        break
                    print(f"  - {p}")
                print(f"\nFound {len(results)} results.\n")
            return True
        except Exception:
            return False

# --- 3. CORE ENGINE ---
class PkgCore:
    def __init__(self):
        self.logger = PkgLogger()
        self.cache = PkgCache(self.logger)
        self.config = self._load_config()

    def _create_default_config(self):
        """Tự động tạo file config mặc định nếu chưa có"""
        try:
            config_dir = os.path.dirname(CONFIG_FILE)
            if not os.path.exists(config_dir):
                os.makedirs(config_dir, exist_ok=True)

            content = (
                "# PKG Configuration File\n"
                "# Generated automatically by PKG\n\n"
                "# Number of compilation cores (or 'auto')\n"
                "CORES=auto\n\n"
                "# Automatically attempt to fix USE flags/masks\n"
                "AUTOFIX=true\n\n"
                "# Prevent removing system critical packages (basic check)\n"
                "SAFE_MODE=true\n"
            )
            
            with open(CONFIG_FILE, 'w') as f:
                f.write(content)
            
            self.logger.info(f"Created default configuration at {CONFIG_FILE}")
            
        except PermissionError:
            # Nếu chạy user thường thì không tạo được ở /etc, bỏ qua
            pass

    def _load_config(self):
        defaults = {"CORES": "auto", "AUTOFIX": "true", "SAFE_MODE": "true"}
        
        # Kiểm tra file config, nếu không có thì tạo
        if not os.path.exists(CONFIG_FILE):
            self._create_default_config()

        # Đọc lại file
        if os.path.exists(CONFIG_FILE):
            try:
                with open(CONFIG_FILE) as f:
                    for line in f:
                        if "=" in line and not line.strip().startswith("#"):
                            k, v = line.strip().split("=", 1)
                            defaults[k.strip()] = v.strip().replace('"', '')
            except Exception:
                pass
        return defaults

    def _parse_use_flags(self, use_str):
        if not use_str:
            return None
        return use_str.replace(",", " ")

    def run_process(self, cmd_args, env_vars=None, stream_output=True):
        if env_vars is None:
            env_vars = {}

        env = os.environ.copy()
        env.update(env_vars)

        cmd_str = " ".join(shlex.quote(arg) for arg in cmd_args)
        
        env_display = ""
        if "USE" in env_vars:
            env_display += f"USE=\"{env_vars['USE']}\" "
        if "MAKEOPTS" in env_vars:
            env_display += f"MAKEOPTS=\"{env_vars['MAKEOPTS']}\" "
            
        self.logger.info(f"Executing: {PkgLogger.BOLD}{env_display}{cmd_str}{PkgLogger.ENDC}")

        try:
            process = subprocess.Popen(
                cmd_args,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                env=env,
                bufsize=1 
            )

            full_log = []
            if stream_output:
                for line in process.stdout:
                    sys.stdout.write(line)
                    full_log.append(line)
            else:
                out, _ = process.communicate()
                full_log.append(out)
                print(out)

            process.wait()
            success = (process.returncode == 0)
            
            self.logger.log_to_file("".join(full_log))
            return success, "".join(full_log)

        except KeyboardInterrupt:
            print() 
            self.logger.warn("Process killed by user.")
            return False, ""
        except FileNotFoundError:
            self.logger.error(f"Command not found: {cmd_args[0]}")
            return False, ""

    # --- MAIN COMMANDS ---
    def install(self, packages, jobs=None, dry_run=False, use_flags=None):
        emerge_cmd = ["emerge", "--verbose"]
        
        if dry_run:
            self.logger.info("DRY-RUN MODE: Simulation only.")
            emerge_cmd.append("--pretend")
        
        emerge_cmd.extend(packages)

        if not dry_run:
            print(f"{PkgLogger.HEADER}Plan to install:{PkgLogger.ENDC} {', '.join(packages)}")
            try:
                confirm = input(f"{PkgLogger.WARNING}Continue? (Y/n): {PkgLogger.ENDC}")
                if confirm.lower() not in ['', 'y', 'yes']:
                    self.logger.warn("Aborted by user.")
                    return
            except KeyboardInterrupt:
                print()
                return

        env = {}
        cores = jobs if jobs else self.config["CORES"]
        if cores and cores != "auto":
            env["MAKEOPTS"] = f"-j{cores}"

        parsed_use = self._parse_use_flags(use_flags)
        if parsed_use:
            self.logger.info(f"Applying custom USE flags: {parsed_use}")
            current_use = os.environ.get("USE", "")
            env["USE"] = f"{current_use} {parsed_use}".strip()

        success, output = self.run_process(emerge_cmd, env)
        
        if not success and not dry_run:
            self._handle_error(output, emerge_cmd, env)

    def remove(self, packages, dry_run=False):
        cmd = ["emerge", "--unmerge"] 
        if dry_run:
            cmd.append("--pretend")
        
        cmd.extend(packages)

        if not dry_run:
            print(f"{PkgLogger.HEADER}Plan to REMOVE:{PkgLogger.ENDC} {', '.join(packages)}")
            try:
                confirm = input(f"{PkgLogger.FAIL}Are you sure? (This can break things) (y/N): {PkgLogger.ENDC}")
                if confirm.lower() not in ['y', 'yes']:
                    self.logger.warn("Aborted.")
                    return
            except KeyboardInterrupt:
                print()
                return

        self.run_process(cmd)

    def update_system(self):
        self.logger.info("Syncing repositories...")
        success, _ = self.run_process(["emerge", "--sync"])
        if success:
            self.cache.update_index()

    def upgrade_world(self, jobs=None, dry_run=False):
        cmd = ["emerge", "--update", "--deep", "--newuse", "--verbose", "@world"]
        
        if dry_run:
            cmd.append("--pretend")
        elif not dry_run:
            try:
                confirm = input(f"{PkgLogger.HEADER}Ready to upgrade system (@world). Continue? (Y/n): {PkgLogger.ENDC}")
                if confirm.lower() not in ['', 'y', 'yes']:
                    self.logger.warn("Aborted.")
                    return
            except KeyboardInterrupt:
                print()
                return

        env = {}
        cores = jobs if jobs else self.config["CORES"]
        if cores and cores != "auto":
            env["MAKEOPTS"] = f"-j{cores}"
            
        self.run_process(cmd, env)

    def search(self, query):
        found_in_cache = self.cache.search(query)
        if not found_in_cache:
            self.run_process(["emerge", "--search", query])

    def _handle_error(self, output, original_cmd, env):
        if "The following USE changes are necessary" in output:
            self.logger.warn("Detected missing USE flags / Keyword masking.")
            if self.config["AUTOFIX"] == "true":
                try:
                    ask = input(f"{PkgLogger.WARNING}Attempt automatic fix (autounmask)? (Y/n): {PkgLogger.ENDC}")
                    if ask.lower() in ["", "y"]:
                        new_cmd = ["emerge", "--autounmask-continue"] + original_cmd[1:] 
                        self.run_process(new_cmd, env)
                        self.logger.info("Please run 'dispatch-conf' if configuration changes are needed.")
                except EOFError:
                    pass

# --- MAIN CLI ---
def main():
    parser = argparse.ArgumentParser(description="PKG - Gentoo Package Manager (Wrapper)", add_help=False)
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    p_install = subparsers.add_parser("install", help="Install packages")
    p_install.add_argument("packages", nargs="+", help="List of packages")
    p_install.add_argument("-j", "--jobs", help="Number of compilation jobs")
    p_install.add_argument("--dry-run", action="store_true", help="Show plan only")
    p_install.add_argument("--use", type=str, help="Custom USE flags")

    p_remove = subparsers.add_parser("remove", help="Remove packages")
    p_remove.add_argument("packages", nargs="+", help="List of packages")
    p_remove.add_argument("--dry-run", action="store_true", help="Simulation")

    subparsers.add_parser("update", help="Sync repositories and update Cache")

    p_upgrade = subparsers.add_parser("upgrade", help="Upgrade system (@world)")
    p_upgrade.add_argument("-j", "--jobs", help="Number of compilation jobs")
    p_upgrade.add_argument("--dry-run", action="store_true", help="Simulation")

    p_search = subparsers.add_parser("search", help="Search packages")
    p_search.add_argument("query", help="Keyword")

    subparsers.add_parser("help", help="Show help")

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()
    pkg = PkgCore()

    if args.command in ["install", "remove", "update", "upgrade"] and os.geteuid() != 0:
        if not getattr(args, 'dry_run', False):
            pkg.logger.error("ROOT privileges (sudo) required to execute.")
            sys.exit(1)

    if args.command == "install":
        pkg.install(args.packages, jobs=args.jobs, dry_run=args.dry_run, use_flags=args.use)
    elif args.command == "remove":
        pkg.remove(args.packages, dry_run=args.dry_run)
    elif args.command == "update":
        pkg.update_system()
    elif args.command == "upgrade":
        pkg.upgrade_world(jobs=args.jobs, dry_run=args.dry_run)
    elif args.command == "search":
        pkg.search(args.query)
    elif args.command == "help":
        parser.print_help()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)